<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spherical Minecraft-like Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #inventory {
      position: fixed;
      left: 50%;
      bottom: 30px;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 2;
    }
    .slot {
      width: 40px;
      height: 40px;
      border: 2px solid #888;
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: #fff;
      box-sizing: border-box;
      border-radius: 6px;
      transition: border-color 0.2s;
    }
    .slot.selected {
      border-color: #ff0;
    }
  </style>
</head>
<body>
  <div id="inventory"></div>
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/controls/OrbitControls.js";

    // --- Basic setup ---
    let scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 7, 18);

    let renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Light ---
    let light = new THREE.DirectionalLight(0xffffff, 1.1);
    light.position.set(10, 20, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    // --- Floating island base ---
    let islandGeometry = new THREE.SphereGeometry(10, 32, 32, 0, Math.PI * 2, 0, Math.PI * 0.6);
    let islandMaterial = new THREE.MeshStandardMaterial({ color: 0x228833, flatShading: true });
    let island = new THREE.Mesh(islandGeometry, islandMaterial);
    island.position.y = 0;
    scene.add(island);

    // --- Spherical blocks ---
    let blocks = [];
    let blockGroup = new THREE.Group();
    scene.add(blockGroup);

    function spawnBlock(pos, type="dirt") {
      let color = type === "dirt" ? 0x8B5A2B : 0x228B22;
      let block = new THREE.Mesh(
        new THREE.SphereGeometry(1, 18, 18),
        new THREE.MeshStandardMaterial({ color, flatShading: true })
      );
      block.position.copy(pos);
      block.userData = {type, cracks: 0, breakTimer: 0};
      blockGroup.add(block);
      blocks.push(block);
      return block;
    }

    // --- Place blocks in a grid on top of island ---
    for(let x=-3; x<=3; x++) for(let z=-3; z<=3; z++) {
      let y = Math.sqrt(Math.max(0, 10*10 - x*x - z*z));
      spawnBlock(new THREE.Vector3(x*2.1, y+1, z*2.1));
    }
    // Place a few tree blocks (leaves)
    spawnBlock(new THREE.Vector3(0, 16, 0), "leaf");
    spawnBlock(new THREE.Vector3(0, 18, 0), "leaf");

    // --- Hand (player's arm) ---
    let hand = new THREE.Mesh(
      new THREE.CylinderGeometry(0.4, 0.6, 3, 16),
      new THREE.MeshStandardMaterial({ color: 0xA0522D, flatShading: true })
    );
    hand.position.set(1, -1, -2.5);
    hand.rotation.x = -Math.PI/5;
    camera.add(hand);
    scene.add(camera);

    // --- Inventory UI ---
    const inventory = Array(9).fill(null);
    let selectedSlot = 0;
    function updateInventoryUI() {
      const invDiv = document.getElementById('inventory');
      invDiv.innerHTML = '';
      for (let i=0; i<9; ++i) {
        let slot = document.createElement('div');
        slot.className = 'slot' + (i===selectedSlot ? ' selected' : '');
        slot.textContent = inventory[i] ? "ðŸŸ¤" : "";
        invDiv.appendChild(slot);
      }
    }
    updateInventoryUI();

    // --- Controls ---
    let controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI/2.1;
    controls.target.set(0, 7, 0);

    // --- Movement ---
    let player = { position: new THREE.Vector3(0, 12, 0), velocity: new THREE.Vector3(), onGround: false };
    function updateCamera() {
      camera.position.x = player.position.x;
      camera.position.y = player.position.y + 2;
      camera.position.z = player.position.z + 10;
      controls.target.copy(player.position);
    }
    // Keyboard
    let move = {w:0, a:0, s:0, d:0, shift:0};
    document.addEventListener('keydown', e => {
      if (e.key === 'w') move.w = 1;
      if (e.key === 'a') move.a = 1;
      if (e.key === 's') move.s = 1;
      if (e.key === 'd') move.d = 1;
      if (e.key === 'Shift') move.shift = 1;
      if (e.key >= '1' && e.key <= '9') {
        selectedSlot = parseInt(e.key)-1;
        updateInventoryUI();
      }
    });
    document.addEventListener('keyup', e => {
      if (e.key === 'w') move.w = 0;
      if (e.key === 'a') move.a = 0;
      if (e.key === 's') move.s = 0;
      if (e.key === 'd') move.d = 0;
      if (e.key === 'Shift') move.shift = 0;
    });

    // --- Block breaking mechanics ---
    let breaking = null, breakStart = 0;
    let mouseDown = false;
    renderer.domElement.addEventListener('mousedown', (event) => {
      mouseDown = true;
    });
    renderer.domElement.addEventListener('mouseup', (event) => {
      mouseDown = false;
      if (breaking) {
        breaking.material.emissive.setHex(0x000000);
        breaking.userData.cracks = 0;
        breaking = null;
      }
    });

    // --- Picking logic ---
    let raycaster = new THREE.Raycaster();
    function getBlockUnderCursor() {
      let mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
      );
      raycaster.setFromCamera(mouse, camera);
      let intersects = raycaster.intersectObjects(blockGroup.children);
      return intersects.length ? intersects[0].object : null;
    }

    // --- Spinning pickup ---
    let pickups = [];
    function spawnPickup(pos, type) {
      let mesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 14, 14),
        new THREE.MeshStandardMaterial({ color: type === "dirt" ? 0x8B5A2B : 0x228B22, flatShading: true })
      );
      mesh.position.copy(pos);
      mesh.userData = {type, age: 0};
      scene.add(mesh);
      pickups.push(mesh);
    }

    // --- Main loop ---
    let clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      let dt = clock.getDelta();

      // Player movement
      let dir = new THREE.Vector3(
        move.d - move.a,
        0,
        move.s - move.w
      );
      if (dir.lengthSq() > 0) {
        dir.normalize();
        let speed = move.shift ? 8 : 4;
        player.position.add(dir.multiplyScalar(speed * dt));
      }

      // Simulate gravity (for fun)
      if (player.position.y > 12) {
        player.position.y -= dt * 2;
      } else {
        player.position.y = 12;
      }
      updateCamera();

      // Block breaking logic
      if (mouseDown) {
        // Raycast from center of screen
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        let intersects = raycaster.intersectObjects(blockGroup.children);
        if (intersects.length) {
          let block = intersects[0].object;
          if (breaking !== block) {
            breaking = block;
            block.userData.cracks = 0;
            breakStart = performance.now();
          }
          // Show cracks as block gets broken
          let timeBreaking = (performance.now() - breakStart) / 1000;
          block.userData.cracks = timeBreaking;
          block.material.emissive.setRGB(timeBreaking/2,0,0);
          if (timeBreaking > 1.2) {
            // Break block
            spawnPickup(block.position, block.userData.type);
            blockGroup.remove(block);
            blocks.splice(blocks.indexOf(block), 1);
            breaking = null;
          }
        }
      }

      // Animate hand
      if (mouseDown && breaking) {
        hand.position.y = -1 + Math.sin(performance.now()/100)*0.2;
      } else {
        hand.position.y = -1;
      }

      // Animate pickups, check for inventory pickup
      for (let i = pickups.length-1; i >= 0; --i) {
        let p = pickups[i];
        p.rotation.y += dt * 6;
        p.userData.age += dt;
        // Pick up if close to player
        if (p.position.distanceTo(player.position) < 2) {
          // Add to first free inventory slot
          let slot = inventory.findIndex(i => i === null);
          if (slot !== -1) {
            inventory[slot] = p.userData.type;
            updateInventoryUI();
            scene.remove(p);
            pickups.splice(i,1);
          }
        }
        // Animate floating
        p.position.y += Math.sin(p.userData.age*5)*0.01;
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
